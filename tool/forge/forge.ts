// deno-lint-ignore-file no-console
/**
 * A monorepo tool for Deno workspaces.
 *
 * Roka ‚Äú**forge**‚Äù is crafted for the community for managing Deno packages
 * developed on GitHub. It can compile binaries, calculate versions, and even
 * create GitHub releases. It works best with monorepos of multiple packages
 * published to JSR.
 *
 * To get started, just run **forge** with `deno run -A jsr:@roka/forge` and
 * you‚Äôre all set! No need for any configuration.
 *
 * ## Packages
 *
 * The repository is treated as a list of Deno packages by **forge**. It
 * supports simple projects with a single package and monorepos that use
 * [Deno workspaces](https://docs.deno.com/runtime/fundamentals/workspaces/).
 *
 * ```sh
 * deno run -A jsr:@roka/forge list
 * ```
 * ```
 * üì¶ example @roka/example 1.2.3
 * üì¶ testing @roka/testing 0.1.0
 * ```
 *
 * By default, every **forge** command applies to all packages in the
 * repository. However, you can filter packages by specifying a list of package
 * directories or using glob patterns.
 *
 * ```sh
 * deno run -A jsr:@roka/forge list "exam*"
 * ```
 *
 * ## Versions
 *
 * Versioning in **forge** is only effective when the repository adheres to
 * {@link https://www.conventionalcommits.org | Conventional Commits}. Any bug
 * fix results in a patch version, while a new feature is introduced in a minor
 * version. Commits marked as _breaking changes_ trigger a new major version.
 *
 * A {@link https://semver.org | semantic version} is calculated for every
 * package at every commit. The new version begins with the latest release, or
 * _0.0.0_ if the package has no releases. It then tracks the commits made
 * since that release.
 *
 * ```sh
 * deno run -A jsr:@roka/forge changelog --emoji
 * ```
 * ```
 * üè∑Ô∏è example@2.0.0-pre.3+fedcba9
 *
 *   test(example): forgot unit-testing (#6)
 *   style(example): nicer code style (#5)
 *   fix(example)!: really fix bug with breaking change (#4)
 *   revert(example): revert bug fix, it broke something (#3)
 *   fix(example) fix bug (#2)
 *   feat(example): introduce new feature (#1)
 * ```
 *
 * The current package version will include a pre-release number, which is
 * calculated based on the number of commits that make a version change.
 * Additionally, the version will have a commit hash appended to it, which is
 * derived from the last commit that updated the package.
 *
 * _**WARNING**: Simple repositories with a single package still need to
 * specify a scope for every commit for that package. For example, a commit
 * summary like ‚Äúfeat: feature‚Äù does not automatically lead to a version
 * change. Instead, it should be formatted as ‚Äúfeat(example): feature‚Äù to
 * indicate that the feature was added to the package._
 *
 * ## Releases
 *
 * ### Bump the versions
 *
 * To start a new release, let‚Äôs first update the package versions in the
 * configuration files. We‚Äôre talking about the `version` field in `deno.json`.
 * If you change this version, it means a new release is coming, and **forge**
 * can help you with that.
 *
 * ```sh
 * deno run -A jsr:@roka/forge bump --release --pr
 * ```
 *
 * The `--release` flag drops the pre-release and build
 * information from the current version, resulting in a version like _2.0.0_.
 * If we had omitted this flag, the release would have been a pre-release.
 *
 * The pull request generated by the `--pr` flag will include changes to the
 * configuration and changelog files. Review and merge these changes, and the
 * release will be ready to roll at the merged commit.
 *
 * At this point, we are ready to publish the packages to [JSR](http://jsr.io).
 * However, before that, let‚Äôs proceed to create a release on GitHub, which is
 * the second step.
 *
 * ### Release on GitHub
 *
 * Great news! The version change is now merged, and GitHub knows the commit
 * hash. Let‚Äôs create a release right here!
 *
 * ```sh
 * deno run -A jsr:@roka/forge release example --draft
 * ```
 *
 * The draft release created with **forge** on GitHub will have the new version
 * number, the commit changelog, and a link to the package documentation on
 * JSR. If everything looks good, go ahead and publish the release. This will
 * create a new release tag for the released package, like _example@2.0.0_.
 *
 * ### Publish to JSR
 *
 * Finally, at this tagged commit, we can publish our packages to JSR.
 *
 * ```sh
 * deno publish
 * ```
 *
 * Simply running this command will work, because the `deno.json` file is
 * up-to-date, and all our changes are committed. Ideally, this step should be
 * executed using a workflow with GitHub actions.
 *
 * ### Automate with Actions
 *
 * Check out the workflows in the [roka](https://github.com/withroka/roka)
 * repository to see how we can automate all three steps: _bump_, _release_,
 * and _publish_. With **forge** taking care of most of the work, we can
 * either chill or find more time for coding. üíÜ‚Äç‚ôÄÔ∏è
 *
 * ## Assets
 *
 * _**WARNING**: This feature is highly experimental._
 *
 * The tool supports a non-standard `compile` extension in the `deno.json`
 * file. Any package with this field will generate release assets during a
 * release.
 *
 * ```json
 * {
 *   "name": "@roka/example",
 *   "version": "2.0.0",
 *   "compile": {
 *     "main": "example.ts"
 *   }
 * }
 * ```
 *
 * A package with the `compile` configuration will be compiled into a binary
 * for every supported Deno [target](https://docs.deno.com/go/compile). These
 * compiled binaries will be bundled and uploaded to the GitHub release as
 * assets.
 *
 * These assets can be created manually as well.
 *
 * ```sh
 * deno run -A jsr:@roka/forge compile example --bundle --checksum
 * ```
 * ```
 * üì¶ Compiled example
 *
 *   üè∫ dist/example/2.0.0/aarch64-apple-darwin.tar.gz
 *   üè∫ dist/example/2.0.0/sha256.txt
 * ```
 *
 * You can even install these binaries for the local user. The **forge** tool
 * itself can be compiled and installed from its source in this manner.
 *
 * ```sh
 * deno run -A jsr:@roka/forge compile forge --install
 * ```
 *
 * Now we can simply run **forge** by its name.
 *
 * ```sh
 * forge --version
 * ```
 * ```
 * forge 0.1.0 (aarch64-apple-darwin)
 * deno 2.2.3
 * v8 13.4.114.11-rusty
 * typescript 5.7.3
 * ```
 *
 * Magic! üîÆ
 *
 * ## Modules
 *
 * This library also offers programmatic functionality through the following
 * modules:
 *
 *  -  {@link [package]}: Retrieve package information.
 *  -  {@link [changelog]}: Generate changelogs.
 *  -  {@link [compile]}: Create binary executables.
 *  -  {@link [bump]}: Bump package versions.
 *  -  {@link [release]}: Create GitHub releases.
 *  -  {@link [version]}: Provide version from compiled binaries.
 *  -  {@link [testing]}: Write tests for **forge**.
 *
 * @todo Add documentation for GitHub workflows.
 * @todo Gracefully handle errors in the CLI.
 *
 * @module forge
 */

import { Command, EnumType, ValidationError } from "@cliffy/command";
import { Table } from "@cliffy/table";
import { pool, pooled } from "@roka/async/pool";
import { bump } from "@roka/forge/bump";
import { changelog } from "@roka/forge/changelog";
import { compile, targets } from "@roka/forge/compile";
import {
  commits,
  type Package,
  releases,
  workspace,
} from "@roka/forge/package";
import { release } from "@roka/forge/release";
import { version } from "@roka/forge/version";
import { join, relative } from "@std/path";

function listCommand() {
  return new Command()
    .description("List packages and versions.")
    .example("forge list", "List all packages.")
    .example("forge list --modules", "List all modules.")
    .arguments("[packages...:file]")
    .option("--modules", "Print exported package modules.", { default: false })
    .action(async ({ modules }, ...filters) => {
      const packages = await workspace({ filters });
      new Table().body(
        packages.map((pkg) => [
          "üì¶",
          pkg.directory,
          modules ? modulesText(pkg) : pkg.config.name,
          pkg.config.version !== undefined ? pkg.version : undefined,
          ...(pkg.latest?.version !== pkg.config.version)
            ? ["üö®", pkg.latest?.version, "üëâ", pkg.config.version]
            : [],
        ]),
      ).render();
    });
}

function modulesText(pkg: Package): string | undefined {
  const name = pkg.config.name;
  if (name === undefined) return undefined;
  const exports = pkg.config.exports ?? {};
  if (typeof exports === "string") return name;
  return Object.keys(exports)
    .map((key) => join(name, relative(".", key)))
    .join("\n");
}

function changelogCommand() {
  return new Command()
    .description("Generate changelogs.")
    .example("forge changelog", "List unreleased changes.")
    .example("forge changelog --type feat --no-breaking", "List new features.")
    .example("forge changelog --markdown --all", "All releases in Markdown.")
    .option("--all", "Generate changelog for all releases.")
    .option("--type=<type:string>", "Commit type.", { collect: true })
    .option("--breaking", "Only breaking changes.")
    .option("--no-breaking", "Skip breaking changes of filtered types.")
    .option("--emoji", "Use emoji for commit summaries.", { default: false })
    .option("--markdown", "Generate Markdown.", { default: false })
    .arguments("[packages...:file]")
    .action(async ({ all, type, breaking, emoji, markdown }, ...filters) => {
      const packages = await workspace({ filters });
      const options = {
        ...type && { type },
        ...breaking !== undefined && { breaking },
        ...markdown ? {} : { markdown: { heading: "üè∑Ô∏è  ", bullet: "  " } },
        emoji,
      };
      async function* changelogs(pkg: Package) {
        const log = await commits(pkg, {
          ...options,
          ...pkg.latest && { range: { from: pkg.latest.tag } },
        });
        if (log.length) {
          yield changelog(log, {
            ...options,
            title: `${pkg.name}@${pkg.version}`,
          });
        }
        if (!all) return;
        const releasesWithCommits = pooled(
          await releases(pkg),
          async (release) => ({
            ...release,
            commits: await commits(pkg, { ...options, ...release }),
          }),
        );
        for await (const release of releasesWithCommits) {
          if (release.commits.length) {
            yield changelog(release.commits, {
              ...options,
              title: `${pkg.name}@${release.tag.name}`,
            });
          }
        }
      }
      for (const pkg of packages) {
        for await (const log of changelogs(pkg)) {
          console.log(log.replace(/ ‚ôªÔ∏è /g, " ‚ôªÔ∏è  "));
        }
      }
    });
}

function compileCommand(targets: string[]) {
  return new Command()
    .description("Compile packages into binary executables.")
    .example("forge compile", "Compile packages.")
    .example("forge compile --install", "Install binaries.")
    .arguments("[packages...:file]")
    .type("target", new EnumType(targets))
    .option("--target=<architecture:target>", "Target OS architecture.", {
      collect: true,
    })
    .option("--bundle", "Zip and bundle artifacts.", { default: false })
    .option("--checksum", "Create a checksum file.", { default: false })
    .option("--install=[directory:file]", "Install for local user.")
    .option("--concurrency=<number:number>", "Max concurrent compilations.")
    .action(async (options, ...filters) => {
      const packages = (await workspace({ filters }))
        .filter((pkg) => pkg.config.compile);
      await pool(
        packages,
        async (pkg) => {
          const artifacts = await compile(pkg, options);
          console.log(`üì¶ Compiled ${pkg.name}`);
          console.log();
          artifacts.forEach((artifact) => console.log("  üè∫", artifact));
          if (options.install) console.log(`  üß© Installed ${pkg.name}`);
          console.log();
        },
        options,
      );
    });
}

function bumpCommand() {
  return new Command()
    .description("Bump versions on package config files.")
    .example("forge bump", "Bump versions.")
    .example("forge bump --release", "Bump to the next release version.")
    .example("forge bump --release --pr", "Create a version bump PR.")
    .example("forge bump --changelog=CHANGELOG.md", "Update changelog file.")
    .arguments("[packages...:file]")
    .option("--release", "Bump to the next release.", { default: false })
    .option("--changelog=<file:string>", "Update changelog file.")
    .option("--pr", "Create a pull request.", { default: false })
    .option("--emoji", "Use emoji for commit changelog.", { default: false })
    .env("GIT_NAME=<name:string>", "Git user name for the bump commit.", {
      prefix: "GIT_",
    })
    .env("GIT_EMAIL=<email:string>", "Git user e-mail for the bump commit.", {
      prefix: "GIT_",
    })
    .env(
      "GITHUB_TOKEN=<token:string>",
      "GitHub personal token for GitHub actions.",
      { prefix: "GITHUB_" },
    )
    .action(async (options, ...filters) => {
      const packages = (await workspace({ filters }))
        .filter((pkg) => pkg.config.version !== undefined);
      if (!packages.length) console.log("üì¶ No packages to release");
      const pr = await bump(packages, options);
      if (pr) {
        console.log(`üöÄ Created bump pull request`);
        console.log();
        console.log(`  [${pr.url}]`);
        console.log();
      } else {
        console.log("üì¶ Bumped package versions");
      }
    });
}

function releaseCommand() {
  return new Command()
    .description("Creates releases for updated packages.")
    .example("forge release", "Create releases and tags for all updates.")
    .example("forge release --draft", "Create draft releases for all updates.")
    .option("--draft", "Create a draft release.", { default: false })
    .option("--emoji", "Use emoji for commit summaries.", { default: false })
    .arguments("[packages...:file]")
    .env(
      "GITHUB_TOKEN=<token:string>",
      "GitHub personal token for GitHub actions.",
      { prefix: "GITHUB_", required: true },
    )
    .action(async (options, ...filters) => {
      const packages = (await workspace({ filters }))
        .filter((pkg) => pkg.config.version !== pkg.latest?.version);
      if (!packages.length) console.log("üì¶ No packages to release");
      await pool(packages, async (pkg) => {
        const [rls, assets] = await release(pkg, options);
        console.log(`üöÄ Created release ${pkg.name}@${pkg.version}`);
        console.log();
        console.log(`  [${rls.url}]`);
        console.log();
        if (assets.length) {
          assets.forEach((x) => console.log(`  üè∫ ${x.name}`));
          console.log();
        }
      }, { concurrency: 1 });
    });
}

if (import.meta.main) {
  let verbose = false;
  await new Command()
    .name("forge")
    .version(await version({ build: true, deno: true }))
    .description("Manage packages.")
    .example("forge", "List all packages.")
    .example("forge list 'core/*'", "List packages in the 'core' directory.")
    .example("forge compile --install", "Compile and install all binaries.")
    .example("forge bump --pr", "Bump versions and create a bump PR.")
    .example("forge release --draft", "Create releases with compiled assets.")
    .usage("<command> [options] [packages...]")
    .option("--verbose", "Print additional information.", {
      hidden: true,
      global: true,
      action: () => verbose = true,
    })
    .error((error, cmd) => {
      if (error instanceof ValidationError) {
        cmd.showHelp();
        console.error(`‚ùå ${error.message}`);
        Deno.exit(1);
      }
      const errors = (error instanceof AggregateError) ? error.errors : [error];
      if (error instanceof AggregateError) error = error.errors[0];
      for (const error of errors) {
        console.error(`‚ùå ${error.message}`);
        if (verbose) console.error(error);
        else if (error["cause"] && error["cause"]["error"]) {
          console.error(error.cause.error);
        }
      }
      Deno.exit(2);
    })
    .default("list")
    .command("list", listCommand())
    .command("changelog", changelogCommand())
    .command("compile", compileCommand(await targets()))
    .command("bump", bumpCommand())
    .command("release", releaseCommand())
    .parse();
}
